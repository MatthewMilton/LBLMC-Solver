/*

Copyright (C) 2018-2019 Matthew Milton

This file is part of the LB-LMC Solver C++ Library.

LB-LMC Solver C++ Library is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LB-LMC Solver C++ Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LB-LMC Solver C++ Library.  If not, see <https://www.gnu.org/licenses/>.

*/

#include "SystemSolverGenerator.hpp"
#include <string>
#include <sstream>
#include <fstream>

namespace LBLMC
{

SystemSolverGenerator::SystemSolverGenerator(const NumType* A, unsigned int dimension, unsigned int num_components, NumType zero_bound) :
	A(A), dimension(dimension), num_components(num_components), zero_bound(zero_bound)
{
	//do nothing else
}

SystemSolverGenerator::SystemSolverGenerator(const SystemSolverGenerator& base) :
	A(base.A), dimension(base.dimension), num_components(base.num_components), zero_bound(base.zero_bound)
{
	//do nothing else
}

void SystemSolverGenerator::reset(const NumType* A, unsigned int dimension, unsigned int num_components, NumType zero_bound)
{
	this->A = A;
	this->dimension = dimension;
	this->num_components = num_components;
	this->zero_bound = zero_bound;
}

void SystemSolverGenerator::reset(const SystemSolverGenerator& base)
{
	A = base.A;
	dimension = base.dimension;
	num_components = base.num_components;
	zero_bound = base.zero_bound;
}

const char* SystemSolverGenerator::generateSystemSolver(std::string& buffer, const char* solver_name,const char* A_name, const char* b_func_name)
{
	std::stringstream sstrm;

	sstrm <<
	"void " << solver_name << "(LBLMC::NumType x["<<dimension<<"], LBLMC::NumType b_components["<<num_components<<"])\n"
	"{\n\t"
		"LBLMC::NumType b[" << dimension << "];\n\n\t";

	sstrm << b_func_name <<
	"(b, b_components);\n\n\t";

	for(int r = 0; r < dimension; r++)
	{
		sstrm << "x[" << r << "] = ";
		if( !(A[dimension*r+0] < zero_bound && A[dimension*r+0] > -zero_bound) )
			sstrm << A_name << "[" << r << "][" << int(0) <<"]*b[" << int(0) << "] ";
		else
			sstrm << "LBLMC::NumType(0.0) ";
		for(int c = 1; c < dimension; c++)
		{
			if( A[dimension*r+c] < zero_bound && A[dimension*r+c] > -zero_bound )
				continue; // A[r,c] is close to zero, so ignore the term.

//			sstrm << "+ " << A_name << "[" << (dimension*r+c) << "]*b[" << c << "] ";
			sstrm << "+ " << A_name << "[" << r << "][" << c <<"]*b[" << c << "] ";
		}

		sstrm << ";\n\t";
	}

	sstrm << "\n}";

	buffer = sstrm.str();
	return buffer.c_str();
}

int SystemSolverGenerator::generateSystemSolverAndExportC(const char* dir, const char* filename, const char* solver_name,const char* A_name, const char* b_func_name)
{
	//std::fstream file;
	std::fstream header;
	std::fstream source;

	std::string hname = dir; hname +=filename; hname += ".hpp";
	std::string sname = dir; sname +=filename; sname += ".cpp";

	try
	{
		//file.open(filename, std::fstream::out | std::fstream::trunc);
		header.open((hname).c_str(), std::fstream::out | std::fstream::trunc);
		source.open((sname).c_str(), std::fstream::out | std::fstream::trunc);
	}
	catch(...)
	{
		header.close();
		source.close();
		return -1;
	}

	header <<
			"/**\n"
			" *\n"
			" * LBLMC Vivado HLS Simulation Engine for FPGA Designs\n"
			" *\n"
			" * Auto-generated by SystemSolverGenerator Object\n"
			" *\n"
			" */\n\n";

	header << "#ifndef " << solver_name << "_HPP\n";
	header << "#define " << solver_name << "_HPP\n\n";
	header << "\n#include \"LBLMC/DataTypes.hpp\"\n";
	header << "#include \""<< A_name << ".hpp\"\n";
	header << "#include \""<< b_func_name << ".hpp\"\n\n";
	//header << "void solveSystem(NumType* x, NumType* b_components);\n\n";
	header << "void " << solver_name << "(LBLMC::NumType x["<<dimension<<"], LBLMC::NumType b_components["<<num_components<<"]);\n\n";
	header << "#endif";
	header.close();

	source << "#include \"" << filename << ".hpp" << "\"\n\n";

	std::string buf;
	source << generateSystemSolver(buf,solver_name,A_name,b_func_name);
	source.close();

	return 0;
}

} // namespace LBLMC
